<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Requests - GP</title>
  <link rel="icon" type="image/png" href="https://gpsite.github.io/gpmedia/img/logo.png">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap"
    rel="stylesheet">

  <!-- Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <!-- Shared Theme Variables -->
  <link rel="stylesheet" href="../../css/theme.css">
    <link rel="stylesheet" href="index.css">
</head>

<body>
  <div class="bg-layer"></div>

  <header id="mainHeader">
    <div class="nav-pill">
      <a href="../../index.html" class="nav-item">
        <i data-lucide="home"></i> Home
      </a>

      <div class="nav-item" id="filterBtn">
        <i data-lucide="filter"></i> Filter
      </div>

      <div class="nav-item" id="sortBtn">
        <i data-lucide="arrow-up-down"></i> Sort
      </div>

      <div class="search-container">
        <input type="text" id="searchInput" class="search-input" placeholder="Search requests...">
      </div>
    </div>

    <!-- Filter Dropdown -->
    <div class="filter-modal" id="filterMenu">
      <div class="filter-option" onclick="setFilter('All')">All</div>
      <div class="filter-option" onclick="setFilter('Game')">Game</div>
      <div class="filter-option" onclick="setFilter('Glitch')">Glitch</div>
      <div class="filter-option" onclick="setFilter('Other')">Other</div>
    </div>

    <!-- Sort Dropdown -->
    <div class="filter-modal" id="sortMenu">
      <div class="filter-option" onclick="setSort('Newest')">Newest</div>
      <div class="filter-option" onclick="setSort('Oldest')">Oldest</div>
      <div class="filter-option" onclick="setSort('Most Liked')">Most Liked</div>
    </div>
  </header>

  <!-- Main Content -->
  <main>
    <div class="content-wrap">
      <!-- Left: Google Form Iframe -->
      <section class="form-panel">
        <iframe src="https://forms.gle/cVCC9Mzd8VZ3jjsMA" title="Request form" class="iframe-container"></iframe>
      </section>

      <!-- Right: Requests List -->
      <section class="glass-panel">
        <div class="panel-header" style="display:flex; justify-content:space-between; align-items:center;">
          <h2 id="listTitle">Requests</h2>
          <div style="font-size:0.9rem; opacity:0.6;" id="listCount">Loading...</div>
        </div>

        <div id="requestsList" class="request-list">
          <!-- Loading state -->
          <div style="text-align:center; padding:40px; opacity:0.6;">
            <i data-lucide="loader-2" class="animate-spin" style="width:24px; height:24px;"></i>
            <p style="margin-top:10px;">Syncing with Backend...</p>
          </div>
        </div>
      </section>
    </div>
  </main>

  <!-- Settings Modal -->
  <div class="settings-overlay" id="settingsOverlay">
    <div class="settings-modal">
      <div class="settings-header">
        <h2>Settings</h2>
        <button class="close-btn" id="closeSettings"><i data-lucide="x"></i></button>
      </div>
      <div class="settings-body">
        <div class="settings-group">
          <h3>Appearance</h3>
          <div class="setting-item">
            <div class="setting-label"><i data-lucide="moon" style="width: 18px;"></i><span>Dark Mode</span></div>
            <div class="toggle-switch" id="themeSwitch"></div>
          </div>
        </div>
        <!-- ... other settings per previous implementation ... -->
      </div>
    </div>
  </div>

  <!-- Logic -->
  <script src="../../js/settings.js"></script>
  <script type="module">
    // === INLINE FIREBASE IMPORTS ===
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-analytics.js";
    import { getFirestore, collection, doc, setDoc, updateDoc, increment, onSnapshot } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-firestore.js";

    // Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyCWcu3ShnqJlxxMNlH13fp6G30exSwJniY",
      authDomain: "gprequests-cb1a2.firebaseapp.com",
      projectId: "gprequests-cb1a2",
      storageBucket: "gprequests-cb1a2.firebasestorage.app",
      messagingSenderId: "1094373870550",
      appId: "1:1094373870550:web:6fb626c84fb6aa5a713277",
      measurementId: "G-K04QTYWZJB"
    };
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const db = getFirestore(app);

    // === SHEET & FIREBASE LOGIC ===
    const SHEET_URL = 'https://sheets.googleapis.com/v4/spreadsheets/1nw0SDop0IeFr6q776thp_eSCZZulaxZBtM55ECrHD5A/values/additions?key=AIzaSyBdnupZe6bJH43XE0Hj77n0AmlR3wVfN9M';
    const REACTIONS_COLLECTION = 'request_reactions';

    async function generateHash(text) {
      const encoder = new TextEncoder();
      const data = encoder.encode(text);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16);
    }

    async function fetchSheetData() {
      try {
        const res = await fetch(SHEET_URL);
        if (!res.ok) throw new Error('Sheet fetch failed');
        const json = await res.json();

        if (!json.values || json.values.length < 2) return [];

        const headers = json.values[0].map(h => (h || '').toLowerCase().trim());
        const rows = json.values.slice(1);

        // Map headers to columns using exact strings provided
        const dateIdx = headers.indexOf('timestamp');
        // const emailIdx = headers.indexOf('email address'); 
        const catIdx = headers.findIndex(h => h.includes('select one')); // Category

        const gameNameIdx = headers.findIndex(h => h.includes("games' name"));
        const gameCatsIdx = headers.findIndex(h => h.includes("choose up to 3 categories"));

        const descIdx = headers.findIndex(h => h.includes("description"));
        const statusIdx = headers.findIndex(h => h === 'status');

        // Debug if needed
        // console.log({ dateIdx, catIdx, gameNameIdx, movieNameIdx, descIdx, statusIdx });

        const items = await Promise.all(rows.map(async (row) => {
          const dateStr = row[dateIdx] || '';
          const status = (statusIdx !== -1) ? (row[statusIdx] || '') : '';
          const categoryRaw = (row[catIdx] || 'Other').trim();
          const category = categoryRaw.toLowerCase();

          // Remove movie requests entirely
          if (category.includes('movie')) return null;

          let title = '';
          let description = '';

          if (category.includes('game')) {
            // Game Request
            title = (gameNameIdx !== -1) ? (row[gameNameIdx] || '') : '';
            description = (gameCatsIdx !== -1) ? (row[gameCatsIdx] || '') : '';
          } else {
            // Glitch or Other
            // Card Title = Select one (Category)
            title = categoryRaw;
            // Card Description = Description
            description = (descIdx !== -1) ? (row[descIdx] || '') : '';
          }

          // Clean up
          title = title.trim();
          description = description.trim();

          // Fallback parsing / validation
          if (!title && !description) return null;
          if (!dateStr) return null;

          // Unique ID generation
          const uniqueString = `${dateStr}_${title}_${description}`;
          const id = await generateHash(uniqueString);

          return {
            id,
            date: dateStr,
            category: (category.includes('game') ? 'Game' : (category.includes('glitch') ? 'Glitch' : 'Other')),
            status,
            title,
            description
          };
        }));

        return items.filter(i => i !== null).reverse();
      } catch (e) {
        console.error("Sheet Error", e);
        return [];
      }
    }

    function subscribeToReactions(callback) {
      return onSnapshot(collection(db, REACTIONS_COLLECTION), (snapshot) => {
        const reactionMap = {};
        snapshot.forEach(docSnap => {
          // Each document is a request ID, containing emoji counts
          const data = docSnap.data();
          reactionMap[docSnap.id] = {
            '‚ù§Ô∏è': data['heart'] || 0,
            'üëé': data['thumbsdown'] || 0,
            'üò¢': data['crying'] || 0,
            'üòä': data['happy'] || 0
          };
        });
        callback(reactionMap);
      });
    }

    async function toggleReaction(requestId, emoji) {
      const emojiKey = { '‚ù§Ô∏è': 'heart', 'üëé': 'thumbsdown', 'üò¢': 'crying', 'üòä': 'happy' }[emoji];
      const storageKey = `gp_reaction_${requestId}_${emojiKey}`;
      const wasReacted = localStorage.getItem(storageKey) === 'true';
      const ref = doc(db, REACTIONS_COLLECTION, requestId);

      // Optimistic Update
      if (wasReacted) {
        localStorage.removeItem(storageKey);
      } else {
        localStorage.setItem(storageKey, 'true');
      }
      render(); // Update UI immediately

      try {
        if (wasReacted) {
          // Was reacted, so we are removing
          await updateDoc(ref, { [emojiKey]: increment(-1) });
          return false;
        } else {
          // Was not reacted, so we are adding
          try {
            await updateDoc(ref, { [emojiKey]: increment(1) });
          } catch (e) {
            // Document doesn't exist, create it
            await setDoc(ref, { heart: 0, thumbsdown: 0, crying: 0, happy: 0 });
            await updateDoc(ref, { [emojiKey]: increment(1) });
          }
          return true;
        }
      } catch (e) {
        console.error("Reaction Error", e);
        // Revert on error
        if (wasReacted) localStorage.setItem(storageKey, 'true');
        else localStorage.removeItem(storageKey);
        render();
        return wasReacted;
      }
    }

    function hasReacted(requestId, emoji) {
      const emojiKey = { '‚ù§Ô∏è': 'heart', 'üëé': 'thumbsdown', 'üò¢': 'crying', 'üòä': 'happy' }[emoji];
      return localStorage.getItem(`gp_reaction_${requestId}_${emojiKey}`) === 'true';
    }

    // === UI LOGIC ===
    lucide.createIcons();

    let allItems = [];
    let reactionMap = {};

    const listContainer = document.getElementById('requestsList');
    const countEl = document.getElementById('listCount');
    const searchInput = document.getElementById('searchInput');

    // --- Render ---
    function render() {
      const term = searchInput.value.toLowerCase();

      let filtered = allItems.filter(item => {
        const combined = (item.title + ' ' + item.description + ' ' + item.status).toLowerCase();
        const matchesTerm = combined.includes(term);

        let matchesCategory = true;
        if (currentFilter !== 'All') {
          matchesCategory = (item.category || '').includes(currentFilter);
        }

        return matchesTerm && matchesCategory;
      });

      // Sorting
      if (currentSort === 'Oldest') {
        filtered.reverse();
      } else if (currentSort === 'Most Liked') {
        filtered.sort((a, b) => {
          const ra = reactionMap[a.id] ? (reactionMap[a.id]['‚ù§Ô∏è'] || 0) : 0;
          const rb = reactionMap[b.id] ? (reactionMap[b.id]['‚ù§Ô∏è'] || 0) : 0;
          return rb - ra;
        });
      } else {
        // Newest (Default)
        filtered.sort((a, b) => {
          return allItems.indexOf(a) - allItems.indexOf(b);
        });
      }

      countEl.textContent = `${filtered.length} Requests`;
      listContainer.innerHTML = '';

      if (filtered.length === 0) {
        listContainer.innerHTML = `<div style="text-align:center; padding:40px; opacity:0.6;">No requests found.</div>`;
        return;
      }

      const frag = document.createDocumentFragment();
      filtered.forEach(item => {
        const reactions = reactionMap[item.id] || { '‚ù§Ô∏è': 0, 'üëé': 0, 'üò¢': 0, 'üòä': 0 };

        const card = document.createElement('div');
        card.className = 'request-card';
        card.style.position = 'relative';

        // Build reactions HTML
        const emojis = ['‚ù§Ô∏è', 'üëé', 'üò¢', 'üòä'];
        let reactionsHTML = '';
        emojis.forEach(emoji => {
          const userReacted = hasReacted(item.id, emoji);
          const count = reactions[emoji] || 0;
          if (count > 0 || userReacted) {
            const displayCount = (userReacted && count === 0) ? 1 : count;
            reactionsHTML += `
               <div class="reaction-bubble ${userReacted ? 'user-reacted' : ''}" data-id="${item.id}" data-emoji="${emoji}">
                 <span class="emoji">${emoji}</span>
                 <span class="count">${displayCount}</span>
               </div>
             `;
          }
        });

        // Status Logic
        let statusClass = 'received';
        let statusText = item.status || 'Received';
        const st = (item.status || '').toLowerCase();

        if (st.includes('progress')) statusClass = 'working';
        else if (st.includes('other')) { statusClass = 'other'; statusText = 'Other'; }
        else if (st.includes('terminated')) statusClass = 'terminated';
        else if (st.includes('received')) statusClass = 'received';
        else if (st.includes('done') || st.includes('complete')) statusClass = 'completed';

        card.innerHTML = `
          <div class="card-content">
            <div class="card-title">${escapeHtml(item.title)}</div>
            <div class="card-desc">${escapeHtml(item.description)}</div>
            <div class="card-meta">
               <span class="status-pill ${statusClass}">${escapeHtml(statusText)}</span>
              <span>${item.date}</span>
              <span>‚Ä¢ ${escapeHtml(item.category)}</span>
            </div>
            <div class="reactions-container">
              ${reactionsHTML}
            </div>
            
            <div class="reaction-pill" data-id="${item.id}">
               <div class="pill-icon-layer">
                 <i data-lucide="plus" style="width:18px;height:18px;"></i>
               </div>
               <div class="pill-options-layer">
                 <button class="emoji-opt" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</button>
                 <button class="emoji-opt" data-emoji="üëé">üëé</button>
                 <button class="emoji-opt" data-emoji="üò¢">üò¢</button>
                 <button class="emoji-opt" data-emoji="üòä">üòä</button>
               </div>
            </div>
          </div>
        `;
        frag.appendChild(card);
      });

      listContainer.appendChild(frag);
      lucide.createIcons();
      bindReactionEvents();
    }

    function bindReactionEvents() {
      document.querySelectorAll('.reaction-pill').forEach(pill => {
        pill.addEventListener('click', (e) => {
          if (e.target.closest('.emoji-opt')) return;
          e.stopPropagation();
          document.querySelectorAll('.reaction-pill.active').forEach(p => {
            if (p !== pill) p.classList.remove('active');
          });
          pill.classList.toggle('active');
        });
      });

      document.querySelectorAll('.emoji-opt').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const emoji = btn.dataset.emoji;
          const pill = btn.closest('.reaction-pill');
          const requestId = pill.dataset.id;
          await toggleReaction(requestId, emoji);
          pill.classList.remove('active');
        });
      });

      document.querySelectorAll('.reaction-bubble').forEach(bubble => {
        bubble.addEventListener('click', async (e) => {
          e.stopPropagation();
          const requestId = bubble.dataset.id;
          const emoji = bubble.dataset.emoji;
          await toggleReaction(requestId, emoji);
        });
      });
    }

    function escapeHtml(text) {
      if (!text) return '';
      return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // --- Init ---
    (async function init() {
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.reaction-pill')) {
          document.querySelectorAll('.reaction-pill.active').forEach(p => p.classList.remove('active'));
        }
      });

      allItems = await fetchSheetData();
      countEl.textContent = `${allItems.length} Requests`;
      render();

      subscribeToReactions((map) => {
        reactionMap = map;
        render();
      });
    })();

    // --- Filter/Sort Logic ---
    let currentFilter = 'All';
    let currentSort = 'Newest';

    const filterBtn = document.getElementById('filterBtn');
    const sortBtn = document.getElementById('sortBtn');
    const filterMenu = document.getElementById('filterMenu');
    const sortMenu = document.getElementById('sortMenu');

    filterBtn.addEventListener('click', (e) => {
      e.stopPropagation();

      // Toggle Logic
      const isActive = filterMenu.classList.contains('active');
      closeMenus(); // Helper to close all
      if (!isActive) {
        filterMenu.classList.add('active');
        positionMenu(filterBtn, filterMenu);
      }
    });

    sortBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isActive = sortMenu.classList.contains('active');
      closeMenus();
      if (!isActive) {
        sortMenu.classList.add('active');
        positionMenu(sortBtn, sortMenu);
      }
    });

    function closeMenus() {
      filterMenu.classList.remove('active');
      sortMenu.classList.remove('active');
    }

    function positionMenu(btn, menu) {
      // Use fixed positioning for reliable placement
      menu.style.position = 'fixed';
      const rect = btn.getBoundingClientRect();
      // Center the menu under the button
      const center = rect.left + (rect.width / 2);

      menu.style.top = (rect.bottom + 12) + 'px';
      menu.style.left = center + 'px';
      menu.style.transform = 'translateX(-50%)';
      menu.style.marginTop = '0'; // Override CSS
    }

    window.setFilter = (val) => {
      currentFilter = val;
      render();
      closeMenus();
    };

    window.setSort = (val) => {
      currentSort = val;
      render();
      closeMenus();
    };

    // Update global click to closeMenus
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#filterBtn') && !e.target.closest('#filterMenu') &&
        !e.target.closest('#sortBtn') && !e.target.closest('#sortMenu')) {
        closeMenus();
      }
    });

    // --- Search Input Listener (Global) ---
    searchInput.addEventListener('input', () => {
      render();
    });

    // --- Theme Sync ---
    const html = document.documentElement;
    const currentTheme = localStorage.getItem('gp-final-theme') || 'dark';
    html.setAttribute('data-theme', currentTheme);

    window.addEventListener('storage', (e) => {
      if (e.key === 'gp-final-theme') {
        html.setAttribute('data-theme', e.newValue);
      }
    });

  </script>
</body>

</html>