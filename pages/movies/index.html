<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Movie Catalog - GP</title>
    <link rel="icon" type="image/png" href="https://gpsite.github.io/gpmedia/img/logo.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">

    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Fuse.js -->
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>

    <!-- Shared Theme Variables -->
    <link rel="stylesheet" href="../../css/theme.css">

    <style>
        :root {
            /* Theme Config - Dark (Default) */
            --bg-dark: url("https://gpsite.github.io/gpmedia/img/catalog/darkcatalog.png");
            --bg-light: url("https://gpsite.github.io/gpmedia/img/catalog/lightcatalog.png");

            --glass: rgba(255, 255, 255, 0.08);
            --glass-strong: rgba(20, 20, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.12);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --accent: #60a5fa;
            /* Blueish to match previous movie theme */
            --accent-glow: rgba(96, 165, 250, 0.4);

            --pill-bg: rgba(255, 255, 255, 0.08);
            --pill-hover: rgba(255, 255, 255, 0.15);

            --shadow-sm: 0 4px 12px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 20px 50px rgba(0, 0, 0, 0.3);

            --transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);

            --header-padding: clamp(15px, 2.5vw, 40px);
        }

        [data-theme="light"] {
            --glass: rgba(255, 255, 255, 0.75);
            --glass-strong: rgba(255, 255, 255, 0.9);
            --glass-border: rgba(0, 0, 0, 0.06);
            --text-primary: #3f6cb6;
            --text-secondary: #365e96;
            --accent: #2563eb;
            --accent-glow: rgba(37, 99, 235, 0.2);
            --pill-bg: rgba(0, 0, 0, 0.04);
            --pill-hover: rgba(0, 0, 0, 0.08);
            --shadow-sm: 0 4px 12px rgba(0, 0, 0, 0.05);
            --shadow-lg: 0 20px 50px rgba(0, 0, 0, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            font-family: 'Outfit', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #000;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        body.no-scroll {
            overflow: hidden;
        }

        body.blur-active main,
        body.blur-active header,
        body.blur-active .hero-container {
            filter: blur(8px);
            transition: filter 0.3s ease;
            pointer-events: none;
        }

        /* Dynamic Background Layer */
        .bg-layer {
            position: fixed;
            inset: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: -2;
            transition: background-image 0.8s ease;
            filter: saturate(40%);
        }

        [data-theme="dark"] .bg-layer {
            background-image: var(--bg-dark);
        }

        [data-theme="light"] .bg-layer {
            background-image: var(--bg-light);
            filter: brightness(1.02);
        }

        /* --- NAVIGATION --- */
        header {
            width: 100%;
            padding: var(--header-padding);
            padding-bottom: 20px;
            display: flex;
            justify-content: center;
            z-index: 100;
            position: fixed;
            /* Fixed nav like Movies page? Or relative like Games? Games is relative. Movies was fixed. Let's go Fixed for better UX with Hero scroll */
            top: 0;
            transition: background 0.3s;
        }

        header.scrolled .nav-pill {
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(20px);
        }

        [data-theme="light"] header.scrolled .nav-pill {
            background: rgba(255, 255, 255, 0.8);
        }

        /* Unified Navbar Pill */
        .nav-pill {
            display: flex;
            align-items: center;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 100px;
            padding: 6px;
            backdrop-filter: blur(16px);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 900px;
            gap: 8px;
            transition: var(--transition);
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 24px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 600;
            border-radius: 100px;
            transition: var(--transition);
            white-space: nowrap;
            cursor: pointer;
        }

        .nav-item:hover,
        .nav-item.active {
            background: var(--pill-hover);
        }

        .nav-item i {
            width: 18px;
            height: 18px;
        }

        .search-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            background: var(--pill-bg);
            border-radius: 100px;
            padding: 2px;
            transition: var(--transition);
        }

        .search-container:focus-within {
            background: var(--pill-hover);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }

        .search-input {
            width: 100%;
            border: none;
            background: transparent;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 1rem;
            padding: 10px 16px;
            outline: none;
        }

        .search-input::placeholder {
            color: var(--text-secondary);
        }

        /* --- HERO SECTION --- */
        .hero-container {
            width: 100%;
            max-width: 1600px;
            margin: 120px auto 40px;
            /* Offset for fixed header */
            padding: 0 var(--header-padding);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hero-box {
            position: relative;
            width: 100%;
            border-radius: 24px;
            overflow: hidden;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            min-height: 60vh;
        }

        .hero-bg {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center 20%;
            transition: var(--transition);
        }

        .hero-overlay-gradient {
            position: absolute;
            inset: 0;
            background: linear-gradient(to right, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.6) 50%, transparent 100%);
            z-index: 1;
        }

        [data-theme="light"] .hero-overlay-gradient {
            background: linear-gradient(to right, rgba(240, 240, 240, 0.9) 0%, rgba(240, 240, 240, 0.7) 50%, transparent 100%);
        }

        .hero-content {
            position: relative;
            z-index: 10;
            max-width: 600px;
            padding: 60px;
        }

        @media (max-width: 768px) {
            .hero-content {
                padding: 30px;
            }

            .hero-overlay-gradient {
                background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.5) 60%, transparent 100%);
            }

            [data-theme="light"] .hero-overlay-gradient {
                background: linear-gradient(to top, rgba(240, 240, 240, 0.95) 0%, rgba(240, 240, 240, 0.7) 60%, transparent 100%);
            }
        }

        .hero-title {
            font-size: clamp(2rem, 4vw, 3.5rem);
            font-weight: 800;
            margin-bottom: 16px;
            line-height: 1.1;
            /* text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); */
        }

        .hero-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .hero-desc {
            font-size: 1.05rem;
            line-height: 1.6;
            margin-bottom: 32px;
            color: var(--text-primary);
            opacity: 0.9;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            max-width: 500px;
        }

        .hero-btn {
            background: var(--text-primary);
            color: var(--glass-strong);
            /* Inverse for contrast */
            border: none;
            padding: 14px 32px;
            border-radius: 100px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            transition: var(--transition);
            box-shadow: 0 0 20px rgba(120, 120, 120, 0.2);
        }

        [data-theme="dark"] .hero-btn {
            color: #000;
            background: #fff;
        }

        [data-theme="light"] .hero-btn {
            color: #fff;
            background: #000;
        }

        .hero-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--accent-glow);
        }

        /* Loading Pulse */
        .loading-pulse {
            animation: pulse 1.5s infinite;
            opacity: 0.7;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 0.8;
            }
        }

        /* --- MAIN GRID --- */
        main {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 var(--header-padding) 60px;
            z-index: 10;
        }

        .section-divider {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 10px 0 24px;
        }

        .diamond {
            width: 8px;
            height: 8px;
            background: var(--accent);
            transform: rotate(45deg);
            box-shadow: 0 0 10px var(--accent);
        }

        .divider-line {
            flex: 1;
            height: 2px;
            background: linear-gradient(90deg, var(--accent) 0%, transparent 100%);
            border-radius: 1px;
        }

        .divider-text {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .movie-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            /* Matches movies aspect better than games square */
            gap: 24px;
        }

        .movie-card {
            position: relative;
            background: var(--glass);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--glass-border);
            aspect-ratio: 2/3;
            cursor: pointer;
            transition: var(--transition);
        }

        .movie-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg);
            border-color: var(--accent);
            z-index: 2;
        }

        .movie-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .movie-info-mini {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 30px 12px 12px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95), transparent);
            opacity: 0;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .movie-card:hover .movie-info-mini {
            opacity: 1;
        }

        .movie-title {
            font-weight: 700;
            font-size: 1rem;
            color: #fff;
            line-height: 1.2;
        }

        .movie-year {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* --- MODALS (Favorites / Watched) --- */
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(24px);
            border: 1px solid var(--glass-border);
            padding: 24px;
            border-radius: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            z-index: 2000;
            display: none;
            flex-direction: column;
            gap: 16px;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            display: flex;
            opacity: 1;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--glass-border);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .modal-close:hover {
            color: #fff;
        }

        .list-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 12px;
            background: var(--pill-bg);
            transition: var(--transition);
            cursor: pointer;
        }

        .list-item:hover {
            background: var(--pill-hover);
        }

        .list-item img {
            width: 40px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
        }

        .list-item-info {
            flex: 1;
        }

        .list-item-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .list-item-remove {
            background: transparent;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 8px;
            opacity: 0.6;
        }

        .list-item-remove:hover {
            opacity: 1;
        }


        /* --- OVERLAY --- */
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 5000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            padding: 20px;
        }

        .overlay.active {
            opacity: 1;
        }

        .overlay-content {
            width: 100%;
            max-width: 1200px;
            height: 95vh;
            background: #111;
            border-radius: 16px;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--glass-border);
        }

        /* Scrollbar */
        .overlay-content::-webkit-scrollbar {
            width: 8px;
        }

        .overlay-content::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .video-wrapper {
            width: 100%;
            aspect-ratio: 16/9;
            background: #000;
            flex-shrink: 0;
            position: relative;
        }

        .video-loader {
            position: absolute;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #000;
            z-index: 10;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loader-text {
            color: #fff;
            font-size: 14px;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.8;
            font-weight: 500;
            text-align: center;
        }

        .loader-sub {
            margin-top: 8px;
            color: var(--text-secondary);
            font-size: 13px;
            max-width: 300px;
            text-align: center;
            line-height: 1.4;
        }

        .video-container {
            width: 100%;
            height: 100%;
        }

        .video-container iframe {
            width: 100%;
            height: 100%;
            border: none;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        .overlay-details {
            padding: 30px;
            flex-grow: 1;
        }

        .overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 20px;
        }

        .overlay-title {
            font-size: 2rem;
            font-weight: 700;
            line-height: 1.1;
        }

        .overlay-meta {
            color: var(--accent);
            font-weight: 600;
            margin-top: 5px;
        }

        .overlay-controls {
            display: flex;
            gap: 12px;
            flex-shrink: 0;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }

        .control-btn i,
        .control-btn svg {
            width: 20px;
            height: 20px;
        }


        /* TV Panel Styles */
        .tv-panel {
            margin-top: 30px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
        }

        .tv-panel h3 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #ddd;
        }

        .season-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .season-tab {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .season-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .season-tab.active {
            background: #fff;
            color: #000;
            font-weight: 700;
        }

        .episode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
        }

        .episode-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            color: #fff;
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
        }

        .episode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .episode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }

        /* Related */
        .related-section {
            margin-top: 40px;
        }

        .related-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .related-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 16px;
        }

        .related-card {
            cursor: pointer;
            transition: opacity 0.2s;
            aspect-ratio: 2/3;
        }

        .related-card:hover {
            opacity: 0.7;
        }

        .related-card img {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            object-fit: cover;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-pill {
                flex-direction: column;
                gap: 12px;
                padding: 16px;
                border-radius: 24px;
            }

            .nav-item {
                width: 100%;
                justify-content: center;
            }

            .search-container {
                width: 100%;
            }

            .hero-title {
                font-size: 2.5rem;
            }

            .hero-container {
                height: 75vh;
            }

            .overlay-content {
                height: 100%;
                border-radius: 0;
            }

            .movie-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            }
        }
    </style>
</head>

<body>
    <div class="bg-layer"></div>

    <!-- Navigation -->
    <header id="mainHeader">
        <div class="nav-pill">
            <a href="../../index.html" class="nav-item">
                <i data-lucide="home"></i> Home
            </a>
            <div class="nav-item" id="favBtn">
                <i data-lucide="heart"></i> Favorites
            </div>
            <div class="nav-item" id="watchedBtn">
                <i data-lucide="eye"></i> Watched
            </div>
            <div class="search-container">
                <input type="text" id="searchInput" class="search-input" placeholder="Search movies & TV...">
            </div>
        </div>
    </header>

    <!-- Hero Section -->
    <div class="hero-container">
        <div class="hero-box">
            <div class="hero-bg" id="heroBg"></div>
            <div class="hero-overlay-gradient"></div>
            <div class="hero-content" id="heroContent">
                <h1 class="hero-title" id="heroTitle">Loading Library...</h1>
                <div class="hero-meta" id="heroMeta"></div>
                <p class="hero-desc" id="heroDesc"></p>
                <button class="hero-btn" id="heroPlayBtn">
                    <i data-lucide="play-circle"></i> Play Now
                </button>
            </div>
        </div>
    </div>

    <main>
        <!-- Divider -->
        <div class="section-divider">
            <div class="diamond"></div>
            <span class="divider-text" id="gridTitle">Featured</span>
            <div class="divider-line"></div>
        </div>

        <div class="movie-grid" id="movieGrid">
            <!-- Injected Movies -->
        </div>
    </main>

    <!-- Favorites Modal -->
    <div class="modal" id="favModal">
        <div class="modal-header">
            <div class="modal-title">Favorites</div>
            <button class="modal-close" id="closeFavBtn"><i data-lucide="x"></i></button>
        </div>
        <div class="list-container" id="favList"></div>
    </div>

    <!-- Watched Modal -->
    <div class="modal" id="watchedModal">
        <div class="modal-header">
            <div class="modal-title">Watched History</div>
            <button class="modal-close" id="closeWatchedBtn"><i data-lucide="x"></i></button>
        </div>
        <div class="list-container" id="watchedList"></div>
    </div>

    <!-- Overlay -->
    <div class="overlay" id="overlay">
        <div class="overlay-content">
            <div class="video-wrapper">
                <div class="video-loader" id="videoLoader">
                    <div class="spinner"></div>
                    <div class="loader-text">George Pickens</div>
                    <div class="loader-sub">If screen is blank, it's still loading. Please wait up to 5 minutes...</div>
                </div>
                <div class="video-container" id="videoContainer"></div>
            </div>

            <div class="overlay-details">
                <div class="overlay-header">
                    <div>
                        <h2 class="overlay-title" id="overlayTitle">Title</h2>
                        <div class="overlay-meta" id="overlayMeta"></div>
                    </div>
                    <div class="overlay-controls">
                        <!-- Controls -->
                        <button class="control-btn" id="overlayFavBtn" title="Toggle Favorite">
                            <i data-lucide="heart"></i>
                        </button>
                        <button class="control-btn" id="closeOverlayBtn" title="Close">
                            <i data-lucide="x"></i>
                        </button>
                    </div>
                </div>

                <p id="overlayDesc" style="color:#ccc; line-height:1.6;"></p>

                <!-- TV Panel -->
                <div id="tvPanel" class="tv-panel" style="display:none;">
                    <h3>Episodes</h3>
                    <div class="season-tabs" id="seasonTabs"></div>
                    <div class="episode-grid" id="episodeGrid"></div>
                </div>

                <!-- Related -->
                <div id="relatedSection" class="related-section" style="display:none;">
                    <h3 class="related-title">You Might Also Like</h3>
                    <div class="related-grid" id="relatedGrid"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // CONFIG & STATE
        const CONFIG_SHEET_URL = "https://sheets.googleapis.com/v4/spreadsheets/1nw0SDop0IeFr6q776thp_eSCZZulaxZBtM55ECrHD5A/values/movies?key=AIzaSyBdnupZe6bJH43XE0Hj77n0AmlR3wVfN9M";
        let GP_BASE = "";
        let TVMAZE_API = "";
        let TMDB_API_KEY = ""; // Loaded from Sheet

        // TESTING: Uncomment the line below to use local proxy instead of AWS
        GP_BASE = "http://localhost:8080/";

        // Dynamic List (Populated from Sheet)
        let DYNAMIC_LIST = [];

        let allMovies = [];
        let currentMovie = null;
        let currentSeason = 1;
        let currentEpisode = 1;
        let tvCache = {};
        let watchTimer = null;

        // Performance: Cache IMDb API responses
        const imdbCache = new Map();
        let isSearching = false; // Prevent duplicate searches
        let searchController = null; // AbortController for cancelling searches
        let fuseInstance = null; // Fuse.js instance for local search

        // Local Storage Lists
        let favorites = JSON.parse(localStorage.getItem('gp-movie-favorites')) || [];
        let watched = JSON.parse(localStorage.getItem('gp-movie-watched')) || [];

        // Theme Init
        const html = document.documentElement;
        const currentTheme = localStorage.getItem('gp-final-theme') || 'dark';
        html.setAttribute('data-theme', currentTheme);

        window.addEventListener('storage', (e) => {
            if (e.key === 'gp-final-theme') {
                html.setAttribute('data-theme', e.newValue);
            }
        });

        // DOM ELEMENTS
        const heroTitle = document.getElementById('heroTitle');
        const heroBg = document.getElementById('heroBg');
        const heroMeta = document.getElementById('heroMeta');
        const heroDesc = document.getElementById('heroDesc');
        const heroPlayBtn = document.getElementById('heroPlayBtn');
        const movieGrid = document.getElementById('movieGrid');
        const gridTitle = document.getElementById('gridTitle');

        // Modal / Overlay Elements
        const overlay = document.getElementById('overlay');
        const favModal = document.getElementById('favModal');
        const watchedModal = document.getElementById('watchedModal');

        // --- FETCH & INIT ---
        async function init() {
            lucide.createIcons();

            // 1. Config & Library
            await fetchConfigAndLibrary();

            // Loading State
            heroTitle.innerText = "Loading Library...";
            heroTitle.parentElement.classList.add('loading-pulse');

            // 2. Parallel Fetch (OPTIMIZED: Limit to first 20 for faster load)
            const listToLoad = DYNAMIC_LIST.length > 0 ? DYNAMIC_LIST.slice(0, 20) : ["The Matrix"];

            const promises = listToLoad.map(title => fetchMovie(title));
            const results = await Promise.all(promises);

            allMovies = results.filter(m => m).map(m => ({
                id: m.id,
                title: m.title,
                titleNoSpace: m.title.toLowerCase().replace(/\s+/g, ''),
                original_title: m.title, // IMDb "l" is the title
                overview: m.overview, // Subtitle from IMDb
                date: m.date,
                poster: m.poster,
                rating: 'N/A', // IMDb suggest doesn't give rating
                type: 'movie' // Default, suggest doesn't explicitly distinguish easy
            }));

            // Clear loading
            heroTitle.parentElement.classList.remove('loading-pulse');

            if (allMovies.length > 0) {
                setupHero(allMovies);
                renderGrid(allMovies);
            } else {
                heroTitle.innerText = "Failed to Load";
                heroDesc.innerText = "Could not load the movie library. Please check the configuration.";
            }
        }

        async function fetchConfigAndLibrary() {
            try {
                const res = await fetch(CONFIG_SHEET_URL);
                const data = await res.json();
                if (data && data.values) {
                    // Config (Rows 2-6 approx, generic loop)
                    data.values.slice(1).forEach((row) => {
                        const key = row[0]; const value = row[1];
                        if (key === 'GP_BASE') GP_BASE = value;
                        if (key === 'TVMAZE_API') TVMAZE_API = value;
                        if (key === 'TMDB_API_KEY') TMDB_API_KEY = value;
                    });

                    // Dynamic Titles: Column C (Index 2), Starting Row 7 (Index 6)
                    const titleRows = data.values.slice(6);
                    DYNAMIC_LIST = titleRows
                        .map(row => row[2]) // Column C
                        .filter(t => t && t.trim().length > 0); // content only

                    console.log("Loaded Titles:", DYNAMIC_LIST.length);
                }
            } catch (err) {
                console.error("Config Error", err);
            }
        }

        async function fetchImdb(query, signal = null) {
            try {
                const safeQuery = query.toLowerCase().trim();
                if (!safeQuery) return [];

                // OPTIMIZATION: Check cache first
                if (imdbCache.has(safeQuery)) {
                    console.log('Using cached result for:', safeQuery);
                    return imdbCache.get(safeQuery);
                }

                const firstChar = safeQuery.charAt(0);
                // Construct IMDb Suggest URL
                const imdbUrl = `https://sg.media-imdb.com/suggests/${firstChar}/${encodeURIComponent(safeQuery)}.json`;

                // Use Proxy
                const proxyUrl = GP_BASE + imdbUrl;

                const res = await fetch(proxyUrl, { signal });
                const text = await res.text();

                // Parse JSONP: imdb$query({...})
                const jsonStart = text.indexOf('(');
                const jsonEnd = text.lastIndexOf(')');
                if (jsonStart === -1 || jsonEnd === -1) return [];

                const jsonStr = text.substring(jsonStart + 1, jsonEnd);
                const data = JSON.parse(jsonStr);

                if (data && data.d) {
                    // OPTIMIZATION: Limit to 20 results max to reduce DOM load
                    const results = data.d.slice(0, 20).map(item => {
                        // CRITICAL: Parse type from IMDb 'q' field
                        // q can be: "feature", "TV series", "TV mini-series", "video", etc.
                        let itemType = 'movie'; // default
                        if (item.q) {
                            const qLower = item.q.toLowerCase();
                            if (qLower.includes('tv') || qLower.includes('series')) {
                                itemType = 'tv';
                            }
                        }

                        return {
                            id: item.id,
                            title: item.l,
                            poster: item.i ? item.i[0] : null,
                            date: item.y ? item.y.toString() : (item.s && item.s.match(/\d{4}/) ? item.s.match(/\d{4}/)[0] : ''),
                            overview: item.s || '', // Use the subtitle as overview
                            type: itemType
                        };
                    });

                    // OPTIMIZATION: Cache the results
                    imdbCache.set(safeQuery, results);
                    return results;
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('Search cancelled:', query);
                } else {
                    console.warn("IMDb Fetch Error", query, e);
                }
            }
            return [];
        }

        async function fetchMovie(title) {
            const results = await fetchImdb(title);
            if (results && results.length > 0) {
                // Try to find exact match
                const exact = results.find(r => r.title.toLowerCase() === title.toLowerCase());
                return exact || results[0];
            }
            return null;
        }

        async function searchMovies(query) {
            return await fetchImdb(query);
        }

        // --- RENDERING ---
        function posterUrl(path) {
            // IMDb returns full URLs
            if (path && path.startsWith('http')) return path;
            return path || ''; // Fallback
        }

        function setupHero(movies) {
            const featured = movies[Math.floor(Math.random() * movies.length)];
            heroTitle.innerText = featured.title;
            heroDesc.innerText = featured.overview;
            heroMeta.innerHTML = `
                <span>${featured.date?.split('-')[0]}</span>
                <span>â€¢</span>
                <span><i data-lucide="star" style="width:16px; display:inline;"></i> ${featured.rating}</span>
            `;
            heroBg.style.backgroundImage = `url('${posterUrl(featured.poster)}')`;
            heroPlayBtn.onclick = () => openOverlay(featured);
            // Icons will be created once at init
        }

        function renderGrid(movies) {
            movieGrid.innerHTML = '';
            movies.forEach(m => {
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.innerHTML = `
                    <img src="${posterUrl(m.poster)}" loading="lazy">
                    <div class="movie-info-mini">
                        <div class="movie-title">${m.title}</div>
                        <div class="movie-year">${m.date?.split('-')[0]}</div>
                    </div>
                `;
                card.onclick = () => openOverlay(m);
                movieGrid.appendChild(card);
            });
        }

        // --- SEARCH ---
        const searchInput = document.getElementById('searchInput');
        let searchDebounce;
        searchInput.addEventListener('input', (e) => {
            const q = e.target.value.trim();
            clearTimeout(searchDebounce);

            // Cancel any pending search requests
            if (searchController) {
                searchController.abort();
                searchController = null;
            }

            searchDebounce = setTimeout(async () => {
                if (!q) {
                    renderGrid(allMovies);
                    gridTitle.innerText = "Featured";
                    isSearching = false;
                    return;
                }

                // OPTIMIZATION: Minimum 2 characters before searching
                if (q.length < 2) {
                    gridTitle.innerText = "Type at least 2 characters...";
                    movieGrid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:40px;">Type at least 2 characters to search</div>';
                    return;
                }

                // OPTIMIZATION: Prevent duplicate searches
                if (isSearching) return;
                isSearching = true;

                gridTitle.innerText = `Searching for "${q}"...`;
                movieGrid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:40px;">Searching...</div>';

                // TWO-TIER SEARCH STRATEGY
                let localResults = [];
                let externalResults = [];

                // 1. FIRST: Search locally with Fuse.js for instant results
                if (!fuseInstance && allMovies.length > 0) {
                    fuseInstance = new Fuse(allMovies, {
                        keys: ['title', 'original_title'],
                        threshold: 0.3,
                        ignoreLocation: true
                    });
                }

                if (fuseInstance) {
                    const fuseResults = fuseInstance.search(q);
                    localResults = fuseResults.map(r => r.item);

                    // Show local results immediately if found
                    if (localResults.length > 0) {
                        renderGrid(localResults);
                        gridTitle.innerText = `Found ${localResults.length} local result${localResults.length !== 1 ? 's' : ''} for "${q}"`;
                    }
                }

                // 2. SECOND: If local results < 5, augment with external API
                // OPTIMIZATION: Only call API if we don't already have enough results
                if (localResults.length < 5) {
                    try {
                        searchController = new AbortController();
                        externalResults = await fetchImdb(q, searchController.signal);
                        searchController = null;

                        // Merge and deduplicate results
                        const allResults = [...localResults];
                        externalResults.forEach(ext => {
                            if (!allResults.find(loc => loc.id === ext.id)) {
                                allResults.push(ext);
                            }
                        });

                        if (allResults.length > 0) {
                            renderGrid(allResults);
                            gridTitle.innerText = `Found ${allResults.length} result${allResults.length !== 1 ? 's' : ''} for "${q}"`;
                        } else {
                            movieGrid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:40px;">No results found.</div>';
                            gridTitle.innerText = `No results for "${q}"`;
                        }
                    } catch (e) {
                        // If aborted, local results are already shown
                        if (e.name !== 'AbortError') {
                            console.error('Search error:', e);
                        }
                        // If error and we have local results, keep showing them
                        if (localResults.length > 0) {
                            // Already rendered above, do nothing
                        } else {
                            movieGrid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:40px;">Search failed. Please try again.</div>';
                            gridTitle.innerText = `Error searching for "${q}"`;
                        }
                    }
                }

                isSearching = false;
            }, 400); // OPTIMIZATION: Reduced debounce since local search is instant
        });


        // --- OVERLAY & VIDEO ---

        async function openOverlay(movie) {
            currentMovie = movie;

            // Check Fav/Watched status
            updateOverlayButtons();

            // Set Watch Timer (10 minutes)
            clearTimeout(watchTimer);
            watchTimer = setTimeout(() => markAsWatched(movie), 600000); // 10 mins

            document.getElementById('overlayTitle').innerText = movie.title;
            document.getElementById('overlayDesc').innerText = movie.overview;
            document.getElementById('overlayMeta').innerText = "";

            // TV Check
            const isTV = (movie.type === 'tv' || movie.type === 'series');
            document.getElementById('tvPanel').style.display = isTV ? 'block' : 'none';

            if (isTV) {
                currentSeason = 1; currentEpisode = 1;
                document.getElementById('overlayMeta').innerText = "S1:E1";
                // Load TV Meta
                const meta = await fetchTvMeta(movie.title);
                renderTvControls(meta);
            }

            // Related
            fetchRelated(movie);

            // Load Video
            loadVideo(movie, currentSeason, currentEpisode);

            overlay.style.display = 'flex';
            document.body.classList.add('no-scroll');
            // Slight delay for animation
            setTimeout(() => overlay.classList.add('active'), 50);
        }

        async function loadVideo(movie, s, e) {
            const container = document.getElementById('videoContainer');
            const loader = document.getElementById('videoLoader');

            container.innerHTML = '';
            loader.style.display = 'flex';

            let tmdbId = movie.id; // Fallback to imdb id if fetch fails (rarely works but safe)

            try {
                // Convert IMDb ID to TMDB ID
                const convertedId = await fetchTmdbId(movie.id);
                if (convertedId) tmdbId = convertedId;
            } catch (err) {
                console.warn('TMDB Conversion Failed', err);
            }

            // Use multiembed.mov with TMDB ID (proxied as requested)
            // Format: https://multiembed.mov/?video_id={tmdb_id}&tmdb=1
            // Format: https://multiembed.mov/?video_id={tmdb_id}&tmdb=1&s={season}&e={episode}

            let playerUrl = "";

            if (movie.type === 'tv' || movie.type === 'series') {
                playerUrl = `${GP_BASE}https://multiembed.mov/?video_id=${tmdbId}&tmdb=1&s=${s}&e=${e}`;
            } else {
                playerUrl = `${GP_BASE}https://multiembed.mov/?video_id=${tmdbId}&tmdb=1`;
            }

            const src = playerUrl;

            const iframe = document.createElement('iframe');
            // Ad-blocking will be handled at proxy level for better compatibility
            iframe.referrerPolicy = 'no-referrer';
            iframe.allow = "autoplay; fullscreen";

            // Monitor for popup attempts from iframe
            let popupMonitor = null;
            let knownWindows = new Set([window]);

            // Check for new windows every 500ms and close them
            const startPopupMonitoring = () => {
                popupMonitor = setInterval(() => {
                    // Get all windows
                    const allWindows = [window];
                    for (let i = 0; i < allWindows.length; i++) {
                        try {
                            if (allWindows[i].opener === window && !knownWindows.has(allWindows[i])) {
                                console.warn('Detected and closing popup window');
                                allWindows[i].close();
                            }
                        } catch (e) {
                            // Cross-origin, can't access
                        }
                    }
                }, 500);
            };

            // onload event
            iframe.onload = () => {
                // Ensure Loader stays for at least 2 seconds (user requested ~2s, but added message for blank screen)
                setTimeout(() => {
                    loader.style.display = 'none';
                    iframe.style.opacity = '1';
                }, 2000);

                // Start monitoring for popups after iframe loads
                startPopupMonitoring();
            };

            iframe.src = src;
            container.appendChild(iframe);

            // Store monitor reference to clear it later
            if (!window.activePopupMonitors) window.activePopupMonitors = [];
            window.activePopupMonitors.push(popupMonitor);
        }

        function closeOverlay() {
            clearTimeout(watchTimer);
            watchTimer = null;

            // Clear all popup monitors
            if (window.activePopupMonitors) {
                window.activePopupMonitors.forEach(monitor => {
                    if (monitor) clearInterval(monitor);
                });
                window.activePopupMonitors = [];
            }

            overlay.classList.remove('active');
            document.body.classList.remove('no-scroll');
            setTimeout(() => {
                overlay.style.display = 'none';
                document.getElementById('videoContainer').innerHTML = ''; // Kill iframe
            }, 300);
        }

        document.getElementById('closeOverlayBtn').onclick = closeOverlay;

        // --- DATA HELPERS ---
        async function fetchTmdbId(imdbId) {
            if (!TMDB_API_KEY) {
                console.error("TMDB_API_KEY is missing!");
                return null;
            }
            try {
                const url = `https://api.themoviedb.org/3/find/${imdbId}?api_key=${TMDB_API_KEY}&external_source=imdb_id`;
                const res = await fetch(url);
                const data = await res.json();

                if (data.movie_results && data.movie_results.length > 0) {
                    return data.movie_results[0].id;
                }
                if (data.tv_results && data.tv_results.length > 0) {
                    return data.tv_results[0].id;
                }
            } catch (e) {
                console.warn("Error fetching TMDB ID:", e);
            }
            return null;
        }

        async function fetchTvMeta(title) {
            if (tvCache[title]) return tvCache[title];
            try {
                // Use TVMAZE_API constant from Google Sheet (singlesearch endpoint)
                const searchUrl = `${TVMAZE_API}?q=${encodeURIComponent(title)}`;
                console.log('Fetching TV metadata from:', searchUrl);

                const searchRes = await fetch(searchUrl);
                const show = await searchRes.json();

                if (show && show.id) {
                    const showId = show.id;

                    // Step 2: Fetch episodes for the show
                    const episodesRes = await fetch(`https://api.tvmaze.com/shows/${showId}/episodes`);
                    const episodes = await episodesRes.json();

                    if (episodes && episodes.length > 0) {
                        const seasons = {};
                        episodes.forEach(e => {
                            if (!seasons[e.season]) seasons[e.season] = 0;
                            seasons[e.season]++;
                        });
                        const meta = {
                            maxS: Math.max(...Object.keys(seasons).map(Number)),
                            counts: seasons
                        };
                        tvCache[title] = meta;
                        console.log(`Loaded ${episodes.length} episodes for "${title}":`, meta);
                        return meta;
                    }
                }
            } catch (e) {
                console.warn('TVMaze fetch error for', title, e);
            }
            // Only use defaults as last resort - but use more reasonable defaults
            console.warn(`Using default values for "${title}" - API fetch failed`);
            return { maxS: 1, counts: { 1: 10 } }; // More conservative defaults: 1 season with 10 episodes
        }

        function renderTvControls(meta) {
            const sTabs = document.getElementById('seasonTabs');
            const eGrid = document.getElementById('episodeGrid');
            sTabs.innerHTML = '';
            eGrid.innerHTML = '';

            for (let s = 1; s <= meta.maxS; s++) {
                const btn = document.createElement('button');
                btn.className = `season-tab ${s === currentSeason ? 'active' : ''}`;
                btn.innerText = `Season ${s}`;
                btn.onclick = () => {
                    currentSeason = s; currentEpisode = 1;
                    renderTvControls(meta);
                    loadVideo(currentMovie, s, 1);
                    document.getElementById('overlayMeta').innerText = `S${s}:E1`;
                };
                sTabs.appendChild(btn);
            }

            const epCount = meta.counts[currentSeason] || 10; // Default to 10 if count not available
            console.log(`Rendering Season ${currentSeason} with ${epCount} episodes`);
            for (let e = 1; e <= epCount; e++) {
                const btn = document.createElement('button');
                btn.className = `episode-btn ${e === currentEpisode ? 'active' : ''}`;
                btn.innerText = e;
                btn.onclick = () => {
                    currentEpisode = e;
                    renderTvControls(meta); // update active
                    loadVideo(currentMovie, currentSeason, e);
                    document.getElementById('overlayMeta').innerText = `S${currentSeason}:E${e}`;
                };
                eGrid.appendChild(btn);
            }
        }

        async function fetchRelated(movie) {
            const grid = document.getElementById('relatedGrid');
            const section = document.getElementById('relatedSection');
            grid.innerHTML = '';
            section.style.display = 'none';

            try {
                // OPTIMIZATION: Fetch related from IMDb using title keywords
                let query = movie.title.split(':')[0].split(' ')[0]; // First word
                const results = await fetchImdb(query);

                if (results && results.length > 0) {
                    let related = results.filter(m => m.id !== movie.id && m.poster).slice(0, 6);
                    if (related.length > 0) {
                        section.style.display = 'block';
                        related.forEach(m => {
                            const el = document.createElement('div');
                            el.className = 'related-card';
                            el.innerHTML = `<img src="${posterUrl(m.poster)}" loading="lazy">`;
                            el.onclick = () => openOverlay(m);
                            grid.appendChild(el);
                        });
                    }
                }
            } catch (e) {
                console.warn('Related fetch error:', e);
            }
        }


        // --- LIST MANAGEMENT (Favs/Watched) ---
        function updateOverlayButtons() {
            const favBtn = document.getElementById('overlayFavBtn');
            const isFav = favorites.find(f => f.id === currentMovie.id);
            favBtn.classList.toggle('active', !!isFav);
        }

        document.getElementById('overlayFavBtn').onclick = () => {
            const idx = favorites.findIndex(f => f.id === currentMovie.id);
            if (idx > -1) favorites.splice(idx, 1);
            else favorites.push(currentMovie);

            localStorage.setItem('gp-movie-favorites', JSON.stringify(favorites));
            updateOverlayButtons();
            renderList('fav');
        };

        function markAsWatched(movie) {
            const isWatched = watched.find(w => w.id === movie.id);
            if (!isWatched) {
                watched.push(movie);
                localStorage.setItem('gp-movie-watched', JSON.stringify(watched));
                renderList('watched');
                console.log(`Marked "${movie.title}" as watched.`);
            }
        }

        function renderList(type) {
            const list = type === 'fav' ? favorites : watched;
            const container = type === 'fav' ? document.getElementById('favList') : document.getElementById('watchedList');

            container.innerHTML = '';
            if (list.length === 0) {
                container.innerHTML = `<div style="text-align:center;color:#666;padding:20px;">Nothing here yet.</div>`;
                return;
            }

            list.forEach(m => {
                const el = document.createElement('div');
                el.className = 'list-item';
                el.innerHTML = `
                    <img src="${posterUrl(m.poster)}">
                    <div class="list-item-info">
                        <div class="list-item-title">${m.title}</div>
                    </div>
                `;

                // Remove Button
                const rmv = document.createElement('button');
                rmv.className = 'list-item-remove';
                rmv.innerHTML = `<i data-lucide="trash-2"></i>`;
                rmv.onclick = (e) => {
                    e.stopPropagation();
                    if (type === 'fav') {
                        favorites = favorites.filter(f => f.id !== m.id);
                        localStorage.setItem('gp-movie-favorites', JSON.stringify(favorites));
                    } else {
                        watched = watched.filter(w => w.id !== m.id);
                        localStorage.setItem('gp-movie-watched', JSON.stringify(watched));
                    }
                    renderList(type);
                    if (currentMovie && currentMovie.id === m.id) updateOverlayButtons();
                };

                el.onclick = () => {
                    closeModals();
                    openOverlay(m);
                };

                el.appendChild(rmv);
                container.appendChild(el);
            });
            // OPTIMIZATION: Only create icons once, not on every list render
        }

        // Modal Toggles
        function openModal(modal) {
            closeModals(); // Close others
            modal.style.display = 'flex';
            document.body.classList.add('blur-active');
            document.body.classList.add('no-scroll');
            setTimeout(() => modal.classList.add('active'), 10);
        }
        function closeModals() {
            favModal.classList.remove('active');
            watchedModal.classList.remove('active');
            document.body.classList.remove('blur-active');
            document.body.classList.remove('no-scroll');
            setTimeout(() => {
                if (!favModal.classList.contains('active')) favModal.style.display = 'none';
                if (!watchedModal.classList.contains('active')) watchedModal.style.display = 'none';
            }, 300);
        }

        document.getElementById('favBtn').onclick = () => {
            renderList('fav');
            openModal(favModal);
        };
        document.getElementById('watchedBtn').onclick = () => {
            renderList('watched');
            openModal(watchedModal);
        };
        document.getElementById('closeFavBtn').onclick = closeModals;
        document.getElementById('closeWatchedBtn').onclick = closeModals;


        // Close Modals on Outside Click
        window.addEventListener('click', (e) => {
            if (favModal.classList.contains('active') && !favModal.contains(e.target) && !document.getElementById('favBtn').contains(e.target)) {
                closeModals();
            }
            if (watchedModal.classList.contains('active') && !watchedModal.contains(e.target) && !document.getElementById('watchedBtn').contains(e.target)) {
                closeModals();
            }
        });

        // Header Scroll
        window.addEventListener('scroll', () => {
            const hdr = document.getElementById('mainHeader');
            if (window.scrollY > 50) hdr.classList.add('scrolled');
            else hdr.classList.remove('scrolled');
        });

        // ============================================
        // AD BLOCKER - Prevent Redirects, Popups, and Downloads
        // ============================================

        // 1. Aggressive popup blocking - track and close ALL popup attempts
        let blockedPopups = 0;
        const originalWindowOpen = window.open;

        window.open = function (...args) {
            blockedPopups++;
            console.warn(`Popup #${blockedPopups} blocked by ad blocker:`, args[0]);

            // Return a fake window object to prevent errors
            return {
                closed: false,
                close: () => { },
                focus: () => { },
                blur: () => { },
                postMessage: () => { }
            };
        };

        // Also override Window.prototype.open
        Window.prototype.open = window.open;

        // 2. Block beforeunload from ads trying to redirect
        let userInitiatedClose = false;
        document.getElementById('closeOverlayBtn').addEventListener('click', function () {
            userInitiatedClose = true;
        });

        window.addEventListener('beforeunload', function (e) {
            if (!userInitiatedClose && overlay.classList.contains('active')) {
                e.preventDefault();
                e.returnValue = '';
                console.warn('Prevented ad redirect attempt');
            }
        });

        // 3. Intercept and block suspicious download attempts
        document.addEventListener('click', function (e) {
            if (e.target.tagName === 'A') {
                const href = e.target.getAttribute('href');
                // Block suspicious download links
                if (href && (
                    href.includes('.exe') ||
                    href.includes('.apk') ||
                    href.includes('.dmg') ||
                    href.includes('download') && !href.includes('multiembed')
                )) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.warn('Blocked suspicious download:', href);
                    return false;
                }
            }
        }, true);

        // 4. Block context menu manipulation (some ads use this)
        document.addEventListener('contextmenu', function (e) {
            // Allow context menu on video container
            if (e.target.closest('.video-container')) {
                return true;
            }
        });

        // 5. Block focus stealing (ads try to focus their window)
        window.addEventListener('blur', function (e) {
            if (overlay.classList.contains('active')) {
                setTimeout(() => {
                    window.focus();
                }, 100);
            }
        });

        console.log('Ad blocker initialized - Popups, redirects, and downloads blocked');


        // Init
        init().then(() => {
            // OPTIMIZATION: Create all icons once after page is loaded
            lucide.createIcons();
        });

    </script>
    <script src="../../js/settings.js"></script>
</body>

</html>