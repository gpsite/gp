<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game Catalog - GP</title>
  <link rel="icon" type="image/png" href="https://gpsite.github.io/gp/img/logo.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700;800&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <script src="https://unpkg.com/@ruffle-rs/ruffle"></script>

  <style>
    :root{
      --bg-image: url("https://gpsite.github.io/gp/img/home/fall-bg.jpg");
      --glass-bg: rgba(255,255,255,0.12);
      --glass-bg-hover: rgba(255,255,255,0.18);
      --glass-border: rgba(255,255,255,0.35);
      --glass-highlight: rgba(255,255,255,0.55);
      --text: #ffffff;
      --muted: #cfcfcf;
      --accent: rgba(255,255,255,0.06);
    }

    html,body{height:100%; margin:0;}
    body{
      color:var(--text);
      font-family:"Poppins","Segoe UI",system-ui,-apple-system,Arial,Helvetica,sans-serif;
      -webkit-font-smoothing:antialiased;
      background: var(--bg-image) center / cover no-repeat fixed;
      display:flex;
      height:100vh;
      overflow:hidden;
    }

    /* Layout */
    .app {
      display:flex;
      width:100%;
      max-width:var(--max-width);
      margin: 28px auto;
      gap:18px;
      padding: 20px;
      box-sizing:border-box;
      align-items:stretch;
      width: calc(100% - 56px);
    }

    /* Sidebar (glass) */
    .sidebar {
      width: 80px;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(12px) saturate(120%);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 var(--glass-highlight);
      border-radius: 20px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      box-sizing:border-box;
      padding-bottom: 10px;
      z-index: 10;
    }

    .circle-btn { width: 46px; height: 46px; background: rgba(0,0,0,0.24); border-radius: 50%; margin: 6px 0; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 18px; cursor: pointer; position: relative; transition: transform .15s ease, box-shadow .15s ease; z-index: 9001;}
    .circle-btn:hover{ transform: translateY(-2px); box-shadow: 0 8px 18px rgba(0,0,0,0.45); }
    .circle-btn input { position: absolute; left: 56px; width: 0; opacity: 0; border: none; outline: none; padding: 6px 10px; border-radius: 10px; background: rgba(0,0,0,0.7); color: #fff; transition: all 0.2s ease; z-index: 9002; }
    .circle-btn.active input { width: 220px; opacity: 1; height: 32px; top: 6px; z-index: 9003;}

    .filter-menu { position: absolute; top: 8px; left: 62px; background: rgba(0,0,0,0.7); border-radius: 10px; padding: 8px; display: flex; flex-direction: row; flex-wrap: wrap; gap: 6px; max-width: 240px; opacity: 0; pointer-events: none; transition: all 0.18s ease; z-index: 1000; }
    .circle-btn.active .filter-menu { opacity: 1; pointer-events: auto; }

    .filter-menu button { background: rgba(255,255,255,0.04); color: #fff; border: none; padding: 6px 8px; border-radius: 6px; white-space: nowrap; cursor: pointer; font-size: 13px; }
    .filter-menu button:hover { background: rgba(255,255,255,0.07); }

    .scrollbar { flex: 1; width:100%; display:flex; align-items:center; justify-content:center; position:relative; margin-top:6px; }
    .track { position:absolute; top:8px; bottom:8px; width: 10px; border-radius: 8px; background: rgba(0,0,0,0.24); }
    .thumb { width: 54px; height: 34px; background: rgba(0,0,0,0.24); border-radius: 10px; position: absolute; top: 8px; cursor: grab; display:flex; flex-direction:column; justify-content:center; align-items:center; }
    .thumb div { width: 40%; height: 3px; background: #fff; margin: 2px 0; border-radius: 2px; opacity: .85; }

    a.home-btn { margin-top: auto; width:46px; height:46px; display:flex; align-items:center; justify-content:center; text-decoration:none; color:#fff; background: rgba(0,0,0,0.24); border-radius:50%; }
    a.home-btn:hover{ transform: translateY(-2px); box-shadow: 0 8px 18px rgba(0,0,0,0.45); }

    /* Catalog (glass) */
    .catalog-frame {
      flex:1;
      border-radius: 16px;
      border: 1px solid var(--glass-border);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding: 14px;
      box-sizing: border-box;
      backdrop-filter: blur(10px) saturate(120%);
      display:flex;
      flex-direction:column;
      min-height: 68vh;
      box-shadow: 0 12px 40px rgba(0,0,0,0.45), inset 0 1px 0 var(--glass-highlight);
    }

    .catalog-inner {
      flex:1;
      border-radius: 10px;
      padding: 12px;
      overflow-y: scroll; 
      scrollbar-width: none; 
      
    }

    .game-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 18px; align-items:start; }
    .game-card { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.16)); border-radius: 12px; box-shadow: 0 18px 40px rgba(0,0,0,0.45); padding: 8px; text-align:center; cursor:pointer; transition: transform .12s ease, box-shadow .12s ease; border: 1px solid rgba(255,255,255,0.03); }
    .game-card:hover { transform: translateY(-6px); }
    .game-card h3 { font-size: 13px; margin: 6px 0; color: #fff; font-weight:700; }
    .game-card img { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; border-radius: 8px; background: #333; display:block; }
    .game-card p { font-size: 11px; color: var(--muted); margin: 6px 0 0; }

    /* overlay for game iframe (above leaves) */
    .game-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.88);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 9999; /* above the leaves */
      padding: 24px;
      box-sizing: border-box;
    }
    .game-overlay iframe, .game-overlay object {
      width: 86vw;
      height: 82vh;
      border: none;
      border-radius: 12px;
      background: #000;
    }
    .overlay-controls { margin-top: 12px; display:flex; gap:10px; }
    .overlay-controls button { background: rgba(255,255,255,0.04); color:#fff; border:none; border-radius:8px; padding:8px 12px; cursor:pointer; }
    .overlay-controls button:hover { background: rgba(255,255,255,0.07); }

    /* Responsive */
    @media (max-width: 920px){
      .app { flex-direction: column; margin: 16px; width: calc(100% - 32px); }
      .sidebar { width: 100%; flex-direction: row; padding: 8px; gap: 8px; border-radius: 12px; }
      .circle-btn input { left: auto; right: 8px; }
      .filter-menu { left: 8px; top: 56px; }
      .catalog-frame { min-height: 60vh; }
      .game-overlay iframe { width: 96vw; height: 72vh; }
    }

    /* Falling leaves overlay (decorative) - lower z than overlay */
    .leaf-layer{
      position:fixed;
      inset:0;
      z-index:8000; /* under the game overlay but above background */
      pointer-events:none;
      overflow:hidden;
    }
    .leaf{
      position:absolute;
      top:-10vh;
      left:0;
      width:1em;
      height:1em;
      transform: translateY(-10vh);
      animation: fall var(--fall-duration, 14s) linear var(--delay, 0s) infinite;
      will-change: transform;
      opacity: var(--opacity, .95);
    }
    .leaf .sway{
      display:inline-block;
      animation: sway var(--sway-duration, 4s) ease-in-out var(--delay, 0s) infinite alternate;
      will-change: transform;
    }
    .leaf .spin{
      display:inline-block;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.25));
      animation: spin var(--spin-duration, 10s) linear var(--delay, 0s) infinite;
      will-change: transform;
    }

    @keyframes fall{
      0%{ transform: translateY(-10vh); }
      100%{ transform: translateY(110vh); }
    }
    @keyframes sway{
      0%{ transform: translateX(calc(var(--sway-range, 32px) * -1)); }
      100%{ transform: translateX(var(--sway-range, 32px)); }
    }
    @keyframes spin{
      100%{ transform: rotate(360deg); }
    }

    @media (prefers-reduced-motion: reduce){
      .leaf-layer{ display:none !important; }
    }
  </style>
</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JWW3SX1V75"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-JWW3SX1V75');
</script>
  
<body>

  <!-- Falling leaves layer (decorative) -->
  <div class="leaf-layer" id="leaf-layer" aria-hidden="true"></div>

  <div class="app" role="main" aria-label="Game catalog application">
    <!-- Sidebar -->
    <div class="sidebar" aria-hidden="false">
      <div class="circle-btn" id="searchBtn" title="Search">
        <i class="fa fa-search"></i>
        <input type="text" id="searchInput" placeholder="Search...">
      </div>

      <div class="circle-btn" id="filterBtn" title="Filters">
        <i class="fa fa-filter"></i>
        <div class="filter-menu" id="filterMenu" aria-hidden="true"></div>
      </div>

      <div class="circle-btn" id="seriesBtn" title="Series">
        <i class="fa fa-list-ol"></i>
        <div class="filter-menu" id="seriesMenu" aria-hidden="true"></div>
      </div>

      <div class="scrollbar" aria-hidden="true">
        <div class="track"></div>
        <div class="thumb" id="thumb"><div></div><div></div><div></div></div>
      </div>

      <a class="home-btn" id="homeBtn" href="../../index.html" title="Home"><i class="fa fa-home"></i></a>
    </div>

    <!-- Catalog -->
    <div class="catalog-frame" role="region" aria-label="Game catalog">
      <div class="catalog-inner" id="catalog">
        <div class="game-grid" id="gameGrid" aria-live="polite" aria-atomic="false"></div>
      </div>
    </div>
  </div>

  <!-- Overlay -->
  <div class="game-overlay" id="gameOverlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div id="gameContainer" aria-label="Game container"></div>
    <div class="overlay-controls">
      <button id="fsBtn" onclick="toggleFullscreen()">Fullscreen</button>
      <button onclick="toggleBorderdFullscreen()">Bordered Fullscreen</button>
      <button onclick="closeOverlay()">Close</button>
    </div>
  </div>

  <!-- Game data + UI logic -->
<script>
    const SHEET_URL = 'https://sheets.googleapis.com/v4/spreadsheets/1nw0SDop0IeFr6q776thp_eSCZZulaxZBtM55ECrHD5A/values/games?key=AIzaSyBdnupZe6bJH43XE0Hj77n0AmlR3wVfN9M';
    const catalog = document.getElementById("catalog");
    const thumb = document.querySelector(".thumb");
    const gameGrid = document.getElementById("gameGrid");
    const track = document.querySelector(".track");
    const searchBtn = document.getElementById("searchBtn");
    const searchInput = document.getElementById("searchInput");
    const filterBtn = document.getElementById("filterBtn");
    const filterMenu = document.getElementById("filterMenu");
    const seriesBtn = document.getElementById("seriesBtn");
    const seriesMenu = document.getElementById("seriesMenu");
    const overlay = document.getElementById("gameOverlay");
    const gameContainer = document.getElementById("gameContainer");

    let allGames = [];
    let categories = new Set();
    let series = new Map();

    // Fetch game data from Google Sheets
    async function fetchGameData() {
      try {
        const response = await fetch(SHEET_URL);
        const data = await response.json();
        const rows = data.values;
        const headers = rows.shift();
        const titleIndex = headers.indexOf('Title');
        const categoryIndex = headers.indexOf('Category');
        const urlIndex = headers.indexOf('URL');
        const thumbnailIndex = headers.indexOf('Thumbnail');
      
        allGames = rows.map(row => ({
          title: row[titleIndex],
          categories: row[categoryIndex] ? row[categoryIndex].split(',').map(c => c.trim()) : [],
          url: row[urlIndex],
          thumbnail: row[thumbnailIndex]
        }));
      
        // Build categories and filters
        categories = new Set();
        allGames.forEach(g => g.categories.forEach(c => categories.add(c)));
        buildFilters();
      
        // ALWAYS render first so the grid shows even if series logic fails
        renderGames(allGames);
      
        // Then try series (won't block initial render if it fails)
        try {
          identifySeries();       // your function (any version)
          buildSeriesFilters();   // guarded below
        } catch (e) {
          console.warn('Series disabled due to error:', e);
        }
      } catch (e) {
        console.error("Error fetching game data", e);
      }
    }

    // Render game cards
    function renderGames(games) {
      gameGrid.innerHTML = "";
      games.forEach(game => {
        const card = document.createElement("div");
        card.className = "game-card";
        card.innerHTML = `
          <h3>${game.title}</h3>
          <img src="${game.thumbnail}" alt="${game.title}">
          <p>${game.categories.join(', ')}</p>
        `;
        card.addEventListener("click", () => openOverlay(game));
        gameGrid.appendChild(card);
      });
    }

    // Build filter buttons
    function buildFilters() {
      filterMenu.innerHTML = "";
      const allBtn = document.createElement("button");
      allBtn.textContent = "All";
      allBtn.onclick = () => renderGames(allGames);
      filterMenu.appendChild(allBtn);
      categories.forEach(cat => {
        const btn = document.createElement("button");
        btn.textContent = cat;
        btn.onclick = () => renderGames(allGames.filter(g => g.categories.includes(cat)));
        filterMenu.appendChild(btn);
      });
    }

    function buildSeriesFilters() {
      seriesMenu.innerHTML = "";

      const allBtn = document.createElement("button");
      allBtn.textContent = "All";
      allBtn.onclick = () => renderGames(allGames);
      seriesMenu.appendChild(allBtn);

      series.forEach((games, label) => {
        const btn = document.createElement("button");
        btn.textContent = label;
        btn.onclick = () => renderGames(games);
        seriesMenu.appendChild(btn);
      });
    }

    function identifySeries() {
      try {
        const sorted = [...allGames]
          .filter(g => g && g.title)
          .sort((a, b) => a.title.localeCompare(b.title, undefined, { sensitivity: 'base' }));
      
        const normalize = s => s.toLowerCase().replace(/\s+/g, ' ').trim();
        const numRegex = /(.+?)\s+([0-9]+|[IVXLCDM]+)$/i;
      
        function baseKey(title) {
          const t = normalize(title);
        
          // If title ends with a number/Roman numeral (not a year), strip it
          const m = t.match(numRegex);
          if (m) {
            const suffix = m[2];
            const n = parseInt(suffix, 10);
            if (!(n >= 1900 && n <= 2099)) return normalize(m[1]);
          }
        
          // Otherwise first two words
          return t.split(" ").slice(0, 2).join(" ");
        }
      
        // Step 1: build raw adjacency groups
        const buckets = new Map();
        let i = 0;
      
        while (i < sorted.length) {
          const key = baseKey(sorted[i].title);
          let run = [sorted[i]];
          let j = i + 1;

          while (j < sorted.length && baseKey(sorted[j].title) === key) {
            run.push(sorted[j]);
            j++;
          }
        
          if (run.length > 1) buckets.set(key, run);
        
          i = j;
        }
      
        // Step 2: retroactively pull in first non-numbered entry
        for (let [key, run] of buckets.entries()) {
          const first = run[0];
          const standaloneCandidateIndex = sorted.findIndex(g => normalize(g.title) === key);
        
          // If the base name appears exactly and isn't already included, add it
          if (standaloneCandidateIndex !== -1) {
            const standalone = sorted[standaloneCandidateIndex];
            if (!run.some(g => g.title === standalone.title)) {
              run.unshift(standalone);
            }
          }
        }
      
        // Step 3: finalize to global map
        series.clear();
        for (const [key, run] of buckets.entries()) {
          const label = run[0].title.split(" ").slice(0, 2).join(" ");
          if (run.length > 1) series.set(label, run);
        }
      } catch (e) {
        console.error("identifySeries dynamic error:", e);
        series.clear();
      }
    }

    // Open game overlay
    function openOverlay(game) {
      gameContainer.innerHTML = "";
      if (game.url.endsWith(".swf")) {
        gameContainer.innerHTML = `
          <object id="gameObject" type="application/x-shockwave-flash" data="${game.url}" width="650" height="450">
            <param name="movie" value="${game.url}">
            <param name="quality" value="high">
            <param name="wmode" value="transparent">
          </object>
        `;
      } else {
        gameContainer.innerHTML = `<iframe id="gameIframe" src="${game.url}" class="embed"></iframe>`;
      }
      overlay.style.display = "flex";
    }

    function closeOverlay() {
      overlay.style.display = "none";
      gameContainer.innerHTML = "";
    }

    function toggleFullscreen() {
      const el = document.querySelector("#gameIframe") || document.querySelector("#gameObject");
      if (!el) return;
      if (!document.fullscreenElement) {
        el.requestFullscreen().catch(err => console.error(err));
      } else {
        document.exitFullscreen();
      }
    }

    function toggleBorderdFullscreen() {
    const iframe = document.querySelector("#gameIframe");
    const swf = document.querySelector("#gameObject");
      
    let src = "";
    if (iframe) src = iframe.src;
    else if (swf) src = swf.getAttribute("data");
    if (!src) return;
      
    const newTab = window.open("", "_blank");
    if (!newTab) return;
      
    newTab.document.write(`
      <html>
        <head>
          <title>${document.title} - Bordered Fullscreen</title>
          <style>
            html, body {
              margin: 0;
              padding: 0;
              width: 100%;
              height: 100%;
              background: #fff;
              display: flex;
              justify-content: center;
              align-items: center;
            }
            iframe, object {
              width: 100%;
              height: 100%;
              border: 4px solid #222;
              box-sizing: border-box;
              background: #fff;
            }
          </style>
        </head>
        <body>
          ${iframe ? `<iframe src="${src}" allowfullscreen></iframe>` : `<object type="application/x-shockwave-flash" data="${src}"></object>`}
        </body>
      </html>
    `);
  }

  function closeOtherMenus(opening) {
    if (opening !== 'filter') filterBtn.classList.remove('active');
    if (opening !== 'series') seriesBtn.classList.remove('active');
    if (opening !== 'search') {
      searchBtn.classList.remove('active');
      searchInput.value = "";
    }
  }


    fetchGameData();

    // Sync scrollbar thumb position
  function updateTrackHole() {
  const trackRect = track.getBoundingClientRect();
  const thumbRect = thumb.getBoundingClientRect();
  const topRel = Math.max(0, thumbRect.top - trackRect.top);
  const bottomRel = Math.min(trackRect.height, topRel + thumbRect.height);

  const h = Math.max(1, Math.round(trackRect.height));
  const t = Math.round(topRel);
  const b = Math.round(bottomRel);
}

// --- SYNC THUMB POSITION ---
function syncThumb() {
  const ratio = catalog.scrollTop / (catalog.scrollHeight - catalog.clientHeight);
  const trackHeight = track.clientHeight - thumb.clientHeight;
  const newTop = track.offsetTop + ratio * trackHeight;
  thumb.style.top = newTop + "px";
  updateTrackHole();
}
catalog.addEventListener("scroll", syncThumb);
window.addEventListener("resize", syncThumb);

// --- DRAG HANDLER ---
let dragging = false;
    let startY, startTop;
    thumb.addEventListener("mousedown", e => {
      dragging = true;
      startY = e.clientY;
      startTop = parseInt(thumb.style.top) || 0;
      thumb.style.cursor = "grabbing";
    });
    document.addEventListener("mousemove", e => {
      if (!dragging) return;
      const dy = e.clientY - startY;
      const trackHeight = track.clientHeight - thumb.clientHeight;
      let newTop = Math.min(track.offsetTop + trackHeight, Math.max(track.offsetTop, startTop + dy));
      thumb.style.top = newTop + "px";
      const ratio = (newTop - track.offsetTop) / trackHeight;
      catalog.scrollTop = ratio * (catalog.scrollHeight - catalog.clientHeight);
    });
    document.addEventListener("mouseup", () => {
      dragging = false;
      thumb.style.cursor = "grab";
    });

    // --- Search functionality ---
    searchBtn.addEventListener("click", () => {
      const active = searchBtn.classList.toggle("active");
      if (active) {
        closeOtherMenus('search');
        searchInput.focus();
      } else {
        searchInput.value = "";
        renderGames(allGames);
      }
    });

    searchInput.addEventListener("input", e => {
      const term = e.target.value.toLowerCase();
      renderGames(
        allGames.filter(g => (g.title || "").toLowerCase().includes(term))
      );
    });

    // --- Filter functionality ---
    filterBtn.addEventListener("click", () => {
      const active = filterBtn.classList.toggle("active");
      if (active) closeOtherMenus('filter');
    });

    seriesBtn.addEventListener("click", () => {
      const active = seriesBtn.classList.toggle("active");
      if (active) closeOtherMenus('series');
    });

    // --- Overlay escape key close ---
    document.addEventListener("keydown", e => {
      if (e.key === "Escape" && overlay.style.display === "flex") {
        closeOverlay();
      }
    });

  </script>

  <!-- Falling leaves generator (copied from GP home) -->
  <script>
    (function(){
      const layer = document.getElementById('leaf-layer');
      if (!layer) return;

      // Respect reduced motion
      try{
        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          return;
        }
      }catch(e){}

      const LEAFS = ['üçÅ','üçÇ','üçÉ'];
      const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);

      // Scale number of leaves by viewport width (with sensible bounds)
      const COUNT = Math.max(12, Math.min(40, Math.round(vw / 40)));

      function rand(min, max){ return Math.random() * (max - min) + min; }

      for (let i = 0; i < COUNT; i++){
        const leaf = document.createElement('span');
        leaf.className = 'leaf';

        const sway = document.createElement('span');
        sway.className = 'sway';

        const spin = document.createElement('span');
        spin.className = 'spin';
        spin.textContent = LEAFS[Math.floor(Math.random() * LEAFS.length)];

        // Random properties
        const startLeftVw = rand(0, 100);
        const sizePx = rand(16, 36);
        const fallDuration = rand(10, 22); // seconds
        const swayDuration = rand(2.2, 5.2); // seconds
        const swayRange = rand(18, 60); // px
        const spinDuration = rand(6, 13); // seconds
        const delay = -rand(0, 22); // negative delay staggers leaves
        const opacity = rand(0.5, 1);

        leaf.style.left = startLeftVw.toFixed(2) + 'vw';
        leaf.style.setProperty('--fall-duration', fallDuration.toFixed(2) + 's');
        leaf.style.setProperty('--sway-duration', swayDuration.toFixed(2) + 's');
        leaf.style.setProperty('--sway-range', swayRange.toFixed(0) + 'px');
        leaf.style.setProperty('--spin-duration', spinDuration.toFixed(2) + 's');
        leaf.style.setProperty('--delay', delay.toFixed(2) + 's');
        leaf.style.setProperty('--opacity', opacity.toFixed(2));

        // Randomize spin direction
        spin.style.animationDirection = Math.random() < 0.5 ? 'normal' : 'reverse';
        spin.style.fontSize = sizePx.toFixed(0) + 'px';

        sway.appendChild(spin);
        leaf.appendChild(sway);
        layer.appendChild(leaf);
      }

      // Optional: update density on resize (basic)
      let resizeTimer = null;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          const current = layer.children.length;
          const vwNow = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
          const target = Math.max(12, Math.min(40, Math.round(vwNow / 40)));
          const toAdd = Math.max(0, target - current);
          for (let i = 0; i < toAdd; i++){
            const evt = new Event('addLeaf');
            layer.dispatchEvent(evt);
          }
        }, 250);
      });

      // Support adding extra leaves later if needed
      layer.addEventListener('addLeaf', () => {
        const leaf = document.createElement('span');
        leaf.className = 'leaf';
        const sway = document.createElement('span');
        sway.className = 'sway';
        const spin = document.createElement('span');
        spin.className = 'spin';
        spin.textContent = LEAFS[Math.floor(Math.random() * LEAFS.length)];

        const startLeftVw = rand(0, 100);
        const sizePx = rand(16, 36);
        const fallDuration = rand(10, 22);
        const swayDuration = rand(2.2, 5.2);
        const swayRange = rand(18, 60);
        const spinDuration = rand(6, 13);
        const delay = -rand(0, 22);
        const opacity = rand(0.5, 1);

        leaf.style.left = startLeftVw.toFixed(2) + 'vw';
        leaf.style.setProperty('--fall-duration', fallDuration.toFixed(2) + 's');
        leaf.style.setProperty('--sway-duration', swayDuration.toFixed(2) + 's');
        leaf.style.setProperty('--sway-range', swayRange.toFixed(0) + 'px');
        leaf.style.setProperty('--spin-duration', spinDuration.toFixed(2) + 's');
        leaf.style.setProperty('--delay', delay.toFixed(2) + 's');
        leaf.style.setProperty('--opacity', opacity.toFixed(2));

        spin.style.animationDirection = Math.random() < 0.5 ? 'normal' : 'reverse';
        spin.style.fontSize = sizePx.toFixed(0) + 'px';

        sway.appendChild(spin);
        leaf.appendChild(sway);
        layer.appendChild(leaf);
      });
    })();
  </script>

</body>
</html>


